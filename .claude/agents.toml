# Medli Project Agent Configuration
# These agents provide domain-specific context for Claude Code when working on each package.

[agents.spec]
name = "spec"
description = "Core types and interfaces for medli - the contract between generators and renderers"

file_patterns = [
  "packages/spec/**"
]

focus_areas = [
  "Frame type definition",
  "Generator interface",
  "Renderer interface",
  "Type compatibility across packages"
]

instructions = """
This package defines the DATA EXCHANGE FORMAT between generators and renderers.

CRITICAL CONSTRAINTS:
- Frame is a pure data type (no methods, no behavior)
- Generator.frame() returns Frame - this is the ONLY output
- Renderer.render() consumes Frame - this is the ONLY input
- Validation happens at generation time, NOT render time
- Renderers TRUST the Frame data they receive

DESIGN PHILOSOPHY:
- Minimize coupling: generators don't know about renderers
- Maximize compatibility: any Generator works with any Renderer
- Keep Frame flat and serializable (could be JSON)

BEFORE ADDING TO FRAME:
1. Is it primitive data (not objects with methods)?
2. Does it represent something renderable?

Run `npm run typecheck` after changes - spec changes affect ALL packages.
"""

[agents.generator-procedural]
name = "generator-procedural"
description = "Procedural generator inspired by p5.js - imperative sketch pattern"

file_patterns = [
  "packages/generators/procedural/**"
]

focus_areas = [
  "Sketch context API (the 'p' parameter)",
  "Draw function pattern",
  "Frame building from procedural calls",
  "p5.js API conventions"
]

instructions = """
INSPIRATION: p5.js (https://p5js.org)

This generator uses an IMPERATIVE, PROCEDURAL pattern where:
1. User provides a draw function: (sketch) => { ... }
2. Draw function is called EVERY FRAME with fresh context
3. User calls methods like sketch.background(), sketch.rect()
4. Generator COLLECTS these calls and BUILDS the Frame

KEY DIFFERENCE FROM p5.js:
- p5.js uses globals: background(220)
- We use parameter: sketch.background("#dcdcdc")
- This allows multiple generators to coexist

DESIGN RULES:
- The Sketch interface is the USER-FACING API
- Methods should feel like p5.js (imperative, chainable where sensible)
- State resets each frame - no accumulation between frames
- Time is available as sketch.time (milliseconds)

WHEN ADDING NEW PRIMITIVES:
1. Add method to Sketch interface (e.g., sketch.circle(x, y, r))
2. Store call data internally during draw execution
3. Include data in returned Frame
4. Follow p5.js naming conventions where applicable

Test with test-app to verify visual output.
"""

[agents.generator-object]
name = "generator-object"
description = "Object generator inspired by three.js - scene graph pattern"

file_patterns = [
  "packages/generators/object/**"
]

focus_areas = [
  "Scene graph structure",
  "SceneObject interface",
  "Scene traversal",
  "three.js patterns"
]

instructions = """
INSPIRATION: three.js (https://threejs.org)

This generator uses a DECLARATIVE, OBJECT-ORIENTED pattern where:
1. User constructs a Scene (the root Generator)
2. User adds SceneObjects as children (Background, shapes, etc.)
3. Scene traverses children to produce a Frame
4. The Frame structure mirrors the scene graph

KEY CONCEPTS:
- Scene IS the Generator (not a wrapper around one)
- SceneObjects have mutable properties (e.g., background.color = "red")
- Changes take effect on NEXT frame() call
- Object graph persists between frames (unlike procedural)
- Future: transformations and grouping for positioning

WHEN ADDING NEW PRIMITIVES:
1. Create new class implementing SceneObject
2. Constructor takes configuration
3. Export from package index

Test with test-app to verify visual output.
"""

[agents.renderer-common]
name = "renderer-common"
description = "Shared renderer functionality"

file_patterns = [
  "packages/renderers/common/**"
]

focus_areas = [
  "Animation loop management",
  "requestAnimationFrame handling",
  "Shared renderer behavior"
]

instructions = """
This package provides SHARED FUNCTIONALITY for all renderers.

WHAT BELONGS HERE:
- Animation loop (loop/stop behavior)
- requestAnimationFrame management
- Any behavior identical across ALL renderers

WHAT DOES NOT BELONG HERE:
- DOM element handling (renderers differ)
- Actual rendering logic
- Platform-specific code

CONSTRAINTS:
- Must work in browser environment (uses requestAnimationFrame)
- No DOM dependencies (those belong in specific renderers)
- Keep minimal - only truly shared code
"""

[agents.renderer-svg]
name = "renderer-svg"
description = "SVG renderer - renders Frame to SVG elements"

file_patterns = [
  "packages/renderers/svg/**"
]

focus_areas = [
  "SVG DOM manipulation",
  "SVGSVGElement setup",
  "SVG element creation and attributes",
  "Efficient SVG updates"
]

instructions = """
This renderer displays Frame data using SVG elements.

RENDERING APPROACH:
- Be efficient: reuse existing elements where possible
- Update attributes rather than recreating elements when feasible
- Use setAttribute() for SVG attributes
- Use document.createElementNS() for new SVG elements

SVG-SPECIFIC CONSIDERATIONS:
- All SVG elements need correct namespace (http://www.w3.org/2000/svg)
- Attribute names differ from HTML (e.g., 'fill' not 'background')
- Group elements with <g> for transforms
"""

[agents.renderer-canvas]
name = "renderer-canvas"
description = "Canvas renderer - renders Frame to HTML5 Canvas"

file_patterns = [
  "packages/renderers/canvas/**"
]

focus_areas = [
  "Canvas 2D API",
  "CanvasRenderingContext2D operations",
  "Efficient canvas drawing"
]

instructions = """
This renderer displays Frame data using HTML5 Canvas.

RENDERING APPROACH:
- Get context ONCE in constructor
- REDRAW everything each render() call (canvas is immediate mode)
- Clear or fill background before drawing shapes

CANVAS-SPECIFIC CONSIDERATIONS:
- Immediate mode: must redraw everything each frame
- Coordinate system: (0,0) is top-left
- Context state: use save()/restore() if changing transforms
- Path-based shapes need beginPath(), fill()/stroke()
"""

[agents.test-app]
name = "test-app"
description = "Visual test application for renderer verification with Playwright"

file_patterns = [
  "packages/test-app/**"
]

exclude_patterns = [
  "packages/test-app/dist/**"
]

focus_areas = [
  "Visual verification workflow",
  "Playwright MCP integration",
  "Generator/renderer combinations",
  "Code display for inspection"
]

instructions = """
This package provides VISUAL VERIFICATION of renderers.

PURPOSE:
- Show all generator/renderer combinations side-by-side
- Display source code for each generator
- Enable Playwright MCP to screenshot and verify output
- Confirm procedural and object generators produce identical visuals

VERIFICATION WORKFLOW:
1. Run: npm run dev
2. Navigate with Playwright: http://localhost:5173
3. Take screenshots to verify rendering
4. Compare procedural vs object output (should match)

WHEN ADDING NEW PRIMITIVES:
1. Update procedural generator example to use new method
2. Update object generator example to use new class
3. Verify both produce identical visual output

DO NOT add production features here - this is for testing only.
"""
